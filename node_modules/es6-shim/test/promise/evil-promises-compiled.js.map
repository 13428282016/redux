{"version":3,"sources":["evil-promises.js"],"names":[],"mappings":";;AAEA,QAAQ,CAAC,sDAAsD,EAAE,YAAY;AAC3E,cAAY,CAAC;;AAEb,SAAO,CAAC,qDAAqD,EAAE,UAAU,IAAI,EAAE;;;;;;;;AAQ7E,QAAI,WAAW,GAAG,UAAU,QAAQ,EAAE;AACpC,UAAI,IAAI,GAAG,IAAI,OAAO,CAAC,QAAQ,CAAC,CAAC;AACjC,YAAM,CAAC,cAAc,CAAC,IAAI,EAAE,WAAW,CAAC,SAAS,CAAC,CAAC;AACnD,aAAO,IAAI,CAAC;KACb,CAAC;AACF,QAAI,CAAC,MAAM,CAAC,cAAc,EAAE;AAAE,aAAO,IAAI,EAAE,CAAC;KAAE;AAAA,AAC9C,UAAM,CAAC,cAAc,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;AAC5C,eAAW,CAAC,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE;AACvD,iBAAW,EAAE,EAAE,KAAK,EAAE,WAAW,EAAE;KACpC,CAAC,CAAC;;AAEH,QAAI,WAAW,GAAG,WAAW,CAAC,OAAO,EAAE,CAAC;AACxC,eAAW,CAAC,IAAI,GAAG,UAAU,CAAC,EAAE;AAC9B,OAAC,CAAC,CAAC,CAAC,CAAC;AACL,OAAC,CAAC,CAAC,CAAC,CAAC;KACN,CAAC;;AAEF,QAAI,aAAa,GAAG,KAAK,CAAC;AAC1B,QAAI,OAAO,CAAC,UAAU,CAAC,EAAE;AAAE,OAAC,CAAC,WAAW,CAAC,CAAC;KAAE,CAAC,CAAC,IAAI,CAAC,UAAU,KAAK,EAAE;AAClE,YAAM,CAAC,WAAW,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC;AACzC,mBAAa,GAAG,IAAI,CAAC;AACrB,YAAM,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;KAC9B,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;GACrB,CAAC,CAAC;CACJ,CAAC,CAAC","file":"evil-promises-compiled.js","sourcesContent":["/* global describe, specify, assert, Promise */\n\ndescribe('Evil promises should not be able to break invariants', function () {\n  'use strict';\n\n  specify('resolving to a promise that calls onFulfilled twice', function (done) {\n    // note that we have to create a trivial subclass, as otherwise the\n    // Promise.resolve(evilPromise) is just the identity function.\n    // (And in fact, most native Promise implementations use a private\n    // [[PromiseConstructor]] field in `Promise.resolve` which can't be\n    // easily patched in an ES5 engine, so instead of\n    // `Promise.resolve(evilPromise)` we'll use\n    // `new Promise(function(r){r(evilPromise);})` below.)\n    var EvilPromise = function (executor) {\n      var self = new Promise(executor);\n      Object.setPrototypeOf(self, EvilPromise.prototype);\n      return self;\n    };\n    if (!Object.setPrototypeOf) { return done(); } // skip test if on IE < 11\n    Object.setPrototypeOf(EvilPromise, Promise);\n    EvilPromise.prototype = Object.create(Promise.prototype, {\n      constructor: { value: EvilPromise }\n    });\n\n    var evilPromise = EvilPromise.resolve();\n    evilPromise.then = function (f) {\n      f(1);\n      f(2);\n    };\n\n    var calledAlready = false;\n    new Promise(function (r) { r(evilPromise); }).then(function (value) {\n      assert.strictEqual(calledAlready, false);\n      calledAlready = true;\n      assert.strictEqual(value, 1);\n    }).then(done, done);\n  });\n});\n"]}