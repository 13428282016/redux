{"version":3,"sources":["visit.js"],"names":[],"mappings":"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","file":"visit-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nvar _assert = require(\"assert\");\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _util = require(\"./util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar getMarkInfo = require(\"private\").makeAccessor();\n\nexports.visitor = {\n  Function: {\n    exit: function exit(path, state) {\n      var node = path.node;\n\n      if (node.generator) {\n        if (node.async) {\n          // Async generator\n          if (state.opts.asyncGenerators === false) return;\n        } else {\n          // Plain generator\n          if (state.opts.generators === false) return;\n        }\n      } else if (node.async) {\n        // Async function\n        if (state.opts.async === false) return;\n      } else {\n        // Not a generator or async function.\n        return;\n      }\n\n      var contextId = path.scope.generateUidIdentifier(\"context\");\n      var argsId = path.scope.generateUidIdentifier(\"args\");\n\n      path.ensureBlock();\n      var bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n\n      var outerBody = [];\n      var innerBody = [];\n\n      bodyBlockPath.get(\"body\").forEach(function (childPath) {\n        var node = childPath.node;\n        if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      var outerFnExpr = getOuterFnExpr(path);\n      // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n      t.assertIdentifier(node.id);\n      var innerFnId = t.identifier(node.id.name + \"$\");\n\n      // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n      var vars = _hoist.hoist(path);\n\n      var didRenameArguments = renameArguments(path, argsId);\n      if (didRenameArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        vars.declarations.push(t.variableDeclarator(argsId, t.identifier(\"arguments\")));\n      }\n\n      var emitter = new _emit.Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      var wrapArgs = [emitter.getContextFunction(innerFnId),\n      // Async functions that are not generators don't care about the\n      // outer function because they don't need it to be marked and don't\n      // inherit from its .prototype.\n      node.generator ? outerFnExpr : t.nullLiteral(), t.thisExpression()];\n\n      var tryLocsList = emitter.getTryLocsList();\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      }\n\n      var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody);\n\n      var wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        path.replaceWith(t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n      }\n\n      // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n      path.requeue();\n    }\n  }\n};\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    var pp = funPath.findParent(function (path) {\n      return path.isProgram() || path.isBlockStatement();\n    });\n\n    if (!pp) {\n      return node.id;\n    }\n\n    var markDecl = getRuntimeMarkDecl(pp);\n    var markedArray = markDecl.declarations[0].id;\n    var funDeclIdArray = markDecl.declarations[0].init.callee.object;\n    t.assertArrayExpression(funDeclIdArray);\n\n    var index = funDeclIdArray.elements.length;\n    funDeclIdArray.elements.push(node.id);\n\n    return t.memberExpression(markedArray, t.numericLiteral(index), true);\n  }\n\n  return node.id;\n}\n\nfunction getRuntimeMarkDecl(blockPath) {\n  var block = blockPath.node;\n  _assert2[\"default\"].ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n  if (info.decl) {\n    return info.decl;\n  }\n\n  info.decl = t.variableDeclaration(\"var\", [t.variableDeclarator(blockPath.scope.generateUidIdentifier(\"marked\"), t.callExpression(t.memberExpression(t.arrayExpression([]), t.identifier(\"map\"), false), [util.runtimeProperty(\"mark\")]))]);\n\n  blockPath.unshiftContainer(\"body\", info.decl);\n\n  return info.decl;\n}\n\nfunction renameArguments(funcPath, argsId) {\n  var state = {\n    didRenameArguments: false,\n    argsId: argsId\n  };\n\n  funcPath.traverse(argumentsVisitor, state);\n\n  // If the traversal replaced any arguments references, then we need to\n  // alias the outer function's arguments binding (be it the implicit\n  // arguments object or some other parameter or variable) to the variable\n  // named by argsId.\n  return state.didRenameArguments;\n}\n\nvar argumentsVisitor = {\n  \"FunctionExpression|FunctionDeclaration\": function FunctionExpressionFunctionDeclaration(path) {\n    path.skip();\n  },\n\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      path.replaceWith(state.argsId);\n      state.didRenameArguments = true;\n    }\n  }\n};\n\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      path.replaceWith(t.memberExpression(this.context, t.identifier(\"_sent\")));\n    }\n  }\n};\n\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function AwaitExpression(path) {\n    // Convert await expressions to yield expressions.\n    var argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    path.replaceWith(t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};"]}