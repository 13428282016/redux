{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["\"use strict\";\n\nvar _classCallCheck = require(\"babel-runtime/helpers/class-call-check\")[\"default\"];\n\nvar _getIterator = require(\"babel-runtime/core-js/get-iterator\")[\"default\"];\n\nexports.__esModule = true;\n\nexports[\"default\"] = function (_ref5) {\n  var t = _ref5.types;\n\n  /**\n   * Test if a VariableDeclaration's declarations contains any Patterns.\n   */\n\n  function variableDeclarationHasPattern(node) {\n    for (var _iterator = (node.declarations /*: Array*/), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var declar = _ref;\n\n      if (t.isPattern(declar.id)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Test if an ArrayPattern's elements contain any RestElements.\n   */\n\n  function hasRest(pattern) {\n    for (var _iterator2 = (pattern.elements /*: Array*/), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var elem = _ref2;\n\n      if (t.isRestElement(elem)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var arrayUnpackVisitor = {\n    ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n      if (state.bindings[path.node.name]) {\n        state.deopt = true;\n        path.stop();\n      }\n    }\n  };\n\n  var DestructuringTransformer = (function () {\n    function DestructuringTransformer(opts) {\n      _classCallCheck(this, DestructuringTransformer);\n\n      this.blockHoist = opts.blockHoist;\n      this.operator = opts.operator;\n      this.arrays = {};\n      this.nodes = opts.nodes || [];\n      this.scope = opts.scope;\n      this.file = opts.file;\n      this.kind = opts.kind;\n    }\n\n    DestructuringTransformer.prototype.buildVariableAssignment = function buildVariableAssignment(id, init) {\n      var op = this.operator;\n      if (t.isMemberExpression(id)) op = \"=\";\n\n      var node = undefined;\n\n      if (op) {\n        node = t.expressionStatement(t.assignmentExpression(op, id, init));\n      } else {\n        node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]);\n      }\n\n      node._blockHoist = this.blockHoist;\n\n      return node;\n    };\n\n    DestructuringTransformer.prototype.buildVariableDeclaration = function buildVariableDeclaration(id, init) {\n      var declar = t.variableDeclaration(\"var\", [t.variableDeclarator(id, init)]);\n      declar._blockHoist = this.blockHoist;\n      return declar;\n    };\n\n    DestructuringTransformer.prototype.push = function push(id, init) {\n      if (t.isObjectPattern(id)) {\n        this.pushObjectPattern(id, init);\n      } else if (t.isArrayPattern(id)) {\n        this.pushArrayPattern(id, init);\n      } else if (t.isAssignmentPattern(id)) {\n        this.pushAssignmentPattern(id, init);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(id, init));\n      }\n    };\n\n    DestructuringTransformer.prototype.toArray = function toArray(node, count) {\n      if (this.file.opts.loose || t.isIdentifier(node) && this.arrays[node.name]) {\n        return node;\n      } else {\n        return this.scope.toArray(node, count);\n      }\n    };\n\n    DestructuringTransformer.prototype.pushAssignmentPattern = function pushAssignmentPattern(pattern, valueRef) {\n      // we need to assign the current value of the assignment to avoid evaluating\n      // it more than once\n\n      var tempValueRef = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n      var declar = t.variableDeclaration(\"var\", [t.variableDeclarator(tempValueRef, valueRef)]);\n      declar._blockHoist = this.blockHoist;\n      this.nodes.push(declar);\n\n      //\n\n      var tempConditional = t.conditionalExpression(t.binaryExpression(\"===\", tempValueRef, t.identifier(\"undefined\")), pattern.right, tempValueRef);\n\n      var left = pattern.left;\n      if (t.isPattern(left)) {\n        var tempValueDefault = t.expressionStatement(t.assignmentExpression(\"=\", tempValueRef, tempConditional));\n        tempValueDefault._blockHoist = this.blockHoist;\n\n        this.nodes.push(tempValueDefault);\n        this.push(left, tempValueRef);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n      }\n    };\n\n    DestructuringTransformer.prototype.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n      // get all the keys that appear in this object before the current spread\n\n      var keys = [];\n\n      for (var i = 0; i < pattern.properties.length; i++) {\n        var prop = pattern.properties[i];\n\n        // we've exceeded the index of the spread property to all properties to the\n        // right need to be ignored\n        if (i >= spreadPropIndex) break;\n\n        // ignore other spread properties\n        if (t.isRestProperty(prop)) continue;\n\n        var key = prop.key;\n        if (t.isIdentifier(key) && !prop.computed) key = t.stringLiteral(prop.key.name);\n        keys.push(key);\n      }\n\n      keys = t.arrayExpression(keys);\n\n      //\n\n      var value = t.callExpression(this.file.addHelper(\"objectWithoutProperties\"), [objRef, keys]);\n      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n    };\n\n    DestructuringTransformer.prototype.pushObjectProperty = function pushObjectProperty(prop, propRef) {\n      if (t.isLiteral(prop.key)) prop.computed = true;\n\n      var pattern = prop.value;\n      var objRef = t.memberExpression(propRef, prop.key, prop.computed);\n\n      if (t.isPattern(pattern)) {\n        this.push(pattern, objRef);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n      }\n    };\n\n    DestructuringTransformer.prototype.pushObjectPattern = function pushObjectPattern(pattern, objRef) {\n      // https://github.com/babel/babel/issues/681\n\n      if (!pattern.properties.length) {\n        this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper(\"objectDestructuringEmpty\"), [objRef])));\n      }\n\n      // if we have more than one properties in this pattern and the objectRef is a\n      // member expression then we need to assign it to a temporary variable so it's\n      // only evaluated once\n\n      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n        var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n        this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n        objRef = temp;\n      }\n\n      //\n\n      for (var i = 0; i < pattern.properties.length; i++) {\n        var prop = pattern.properties[i];\n        if (t.isRestProperty(prop)) {\n          this.pushObjectRest(pattern, objRef, prop, i);\n        } else {\n          this.pushObjectProperty(prop, objRef);\n        }\n      }\n    };\n\n    DestructuringTransformer.prototype.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {\n      // not an array so there's no way we can deal with this\n      if (!t.isArrayExpression(arr)) return false;\n\n      // pattern has less elements than the array and doesn't have a rest so some\n      // elements wont be evaluated\n      if (pattern.elements.length > arr.elements.length) return;\n      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return false;\n\n      for (var _iterator3 = (pattern.elements /*: Array*/), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref3 = _i3.value;\n        }\n\n        var elem = _ref3;\n\n        // deopt on holes\n        if (!elem) return false;\n\n        // deopt on member expressions as they may be included in the RHS\n        if (t.isMemberExpression(elem)) return false;\n      }\n\n      for (var _iterator4 = (arr.elements /*: Array*/), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {\n        var _ref4;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref4 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref4 = _i4.value;\n        }\n\n        var elem = _ref4;\n\n        // deopt on spread elements\n        if (t.isSpreadElement(elem)) return false;\n      }\n\n      // deopt on reference to left side identifiers\n      var bindings = t.getBindingIdentifiers(pattern);\n      var state = { deopt: false, bindings: bindings };\n      this.scope.traverse(arr, arrayUnpackVisitor, state);\n      return !state.deopt;\n    };\n\n    DestructuringTransformer.prototype.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {\n      for (var i = 0; i < pattern.elements.length; i++) {\n        var elem = pattern.elements[i];\n        if (t.isRestElement(elem)) {\n          this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));\n        } else {\n          this.push(elem, arr.elements[i]);\n        }\n      }\n    };\n\n    DestructuringTransformer.prototype.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {\n      if (!pattern.elements) return;\n\n      // optimise basic array destructuring of an array expression\n      //\n      // we can't do this to a pattern of unequal size to it's right hand\n      // array expression as then there will be values that wont be evaluated\n      //\n      // eg: let [a, b] = [1, 2];\n\n      if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n        return this.pushUnpackedArrayPattern(pattern, arrayRef);\n      }\n\n      // if we have a rest then we need all the elements so don't tell\n      // `scope.toArray` to only get a certain amount\n\n      var count = !hasRest(pattern) && pattern.elements.length;\n\n      // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n      // return a locally bound identifier if it's been inferred to be an array,\n      // otherwise it'll be a call to a helper that will ensure it's one\n\n      var toArray = this.toArray(arrayRef, count);\n\n      if (t.isIdentifier(toArray)) {\n        // we've been given an identifier so it must have been inferred to be an\n        // array\n        arrayRef = toArray;\n      } else {\n        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n        this.arrays[arrayRef.name] = true;\n        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n      }\n\n      //\n\n      for (var i = 0; i < pattern.elements.length; i++) {\n        var elem = pattern.elements[i];\n\n        // hole\n        if (!elem) continue;\n\n        var elemRef = undefined;\n\n        if (t.isRestElement(elem)) {\n          elemRef = this.toArray(arrayRef);\n\n          if (i > 0) {\n            elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier(\"slice\")), [t.numericLiteral(i)]);\n          }\n\n          // set the element to the rest element argument since we've dealt with it\n          // being a rest already\n          elem = elem.argument;\n        } else {\n          elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);\n        }\n\n        this.push(elem, elemRef);\n      }\n    };\n\n    DestructuringTransformer.prototype.init = function init(pattern, ref) {\n      // trying to destructure a value that we can't evaluate more than once so we\n      // need to save it to a variable\n\n      if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n        var memo = this.scope.maybeGenerateMemoised(ref, true);\n        if (memo) {\n          this.nodes.push(this.buildVariableDeclaration(memo, ref));\n          ref = memo;\n        }\n      }\n\n      //\n\n      this.push(pattern, ref);\n\n      return this.nodes;\n    };\n\n    return DestructuringTransformer;\n  })();\n\n  return {\n    visitor: {\n      ExportNamedDeclaration: function ExportNamedDeclaration(path) {\n        var declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n\n        var specifiers = [];\n\n        for (var _name in path.getOuterBindingIdentifiers(path)) {\n          var id = t.identifier(_name);\n          specifiers.push(t.exportSpecifier(id, id));\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n      },\n\n      ForXStatement: function ForXStatement(path, file) {\n        var node = path.node;\n        var scope = path.scope;\n\n        var left = node.left;\n\n        if (t.isPattern(left)) {\n          // for ({ length: k } in { abc: 3 });\n\n          var temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [t.variableDeclarator(temp)]);\n\n          path.ensureBlock();\n\n          node.body.body.unshift(t.variableDeclaration(\"var\", [t.variableDeclarator(left, temp)]));\n\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) return;\n\n        var pattern = left.declarations[0].id;\n        if (!t.isPattern(pattern)) return;\n\n        var key = scope.generateUidIdentifier(\"ref\");\n        node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]);\n\n        var nodes = [];\n\n        var destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          file: file,\n          scope: scope,\n          nodes: nodes\n        });\n\n        destructuring.init(pattern, key);\n\n        path.ensureBlock();\n\n        var block = node.body;\n        block.body = nodes.concat(block.body);\n      },\n\n      CatchClause: function CatchClause(_ref6, file) {\n        var node = _ref6.node;\n        var scope = _ref6.scope;\n\n        var pattern = node.param;\n        if (!t.isPattern(pattern)) return;\n\n        var ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n\n        var nodes = [];\n\n        var destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          file: file,\n          scope: scope,\n          nodes: nodes\n        });\n        destructuring.init(pattern, ref);\n\n        node.body.body = nodes.concat(node.body.body);\n      },\n\n      AssignmentExpression: function AssignmentExpression(path, file) {\n        var node = path.node;\n        var scope = path.scope;\n\n        if (!t.isPattern(node.left)) return;\n\n        var nodes = [];\n\n        var destructuring = new DestructuringTransformer({\n          operator: node.operator,\n          file: file,\n          scope: scope,\n          nodes: nodes\n        });\n\n        var ref = undefined;\n        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {\n          ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n          nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]));\n\n          if (t.isArrayExpression(node.right)) {\n            destructuring.arrays[ref.name] = true;\n          }\n        }\n\n        destructuring.init(node.left, ref || node.right);\n\n        if (ref) {\n          nodes.push(t.expressionStatement(ref));\n        }\n\n        path.replaceWithMultiple(nodes);\n      },\n\n      VariableDeclaration: function VariableDeclaration(path, file) {\n        var node = path.node;\n        var scope = path.scope;\n        var parent = path.parent;\n\n        if (t.isForXStatement(parent)) return;\n        if (!parent || !path.container) return; // i don't know why this is necessary - TODO\n        if (!variableDeclarationHasPattern(node)) return;\n\n        var nodes = [];\n        var declar = undefined;\n\n        for (var i = 0; i < node.declarations.length; i++) {\n          declar = node.declarations[i];\n\n          var patternId = declar.init;\n          var pattern = declar.id;\n\n          var destructuring = new DestructuringTransformer({\n            blockHoist: node._blockHoist,\n            nodes: nodes,\n            scope: scope,\n            kind: node.kind,\n            file: file\n          });\n\n          if (t.isPattern(pattern)) {\n            destructuring.init(pattern, patternId);\n\n            if (+i !== node.declarations.length - 1) {\n              // we aren't the last declarator so let's just make the\n              // last transformed node inherit from us\n              t.inherits(nodes[nodes.length - 1], declar);\n            }\n          } else {\n            nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));\n          }\n        }\n\n        path.replaceWithMultiple(nodes);\n      }\n    }\n  };\n};\n\nmodule.exports = exports[\"default\"];"]}